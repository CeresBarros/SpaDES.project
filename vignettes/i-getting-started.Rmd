---
title: "SpaDES project setup"
author: "Eliot McIntire"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SpaDES project setup}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE
)

SuggestedPkgsNeeded <- c("SpaDES.core", "igraph", "visNetwork", "ellipsis", "terra")
hasSuggests <- all(sapply(SuggestedPkgsNeeded, require, character.only = TRUE, quietly = TRUE))
useSuggests <- !(tolower(Sys.getenv("_R_CHECK_DEPENDS_ONLY_")) == "true")

knitr::opts_chunk$set(eval = hasSuggests && useSuggests && 
                        Sys.info()["user"] == "emcintir")# && interactive())
options(Ncpus = 1)

# options(Require.clonePkgs = TRUE)

```

```{r setCRAN,echo=FALSE}
## cleanup / restore state
if (is.null(getOption("repos")) || !"CRAN" %in% names(getOption("repos"))) {
 options(repos = c(CRAN = "https://cloud.r-project.org"))
}
```

# Getting started

`SpaDES` is a set of R packages that provide a modular framework for doing ecological analysis, simulation, forecasting and other ecological objectives. The key element of a `SpaDES` analysis is the *module*: a chunk of code that does something and has computer- and human-readable metadata associated with it. It is common within a `SpaDES` project that a user will use many modules, created by them or by others. This potential *growth* of a project complexity leads to a number of challenges including paths (e.g., for data inputs, outputs, figures, modules, packages), package dependencies, and simultaneous module development and synchornization. While a `SpaDES` project can be developed like any other that a user may have already been familiar with, this `SpaDES.project` package helps to create a clean, repeatable set up for any package. The defaults will keep a given project files and pacakges isolated from other projects on a computer. 

Below, we show a number of examples, from simple to moderate complexity, of the usage of `setupProject`. Since, there are a number pre-requisites, we start there.

## Installing prerequisites, system dependencies, R and Rstudio

To begin, users will need to have installed R, Rstudio and potentially other system-level dependencies.
[See vignette here](https://spades-project.predictiveecology.org/articles/iv-LandR-fireSense.html)


## Start working with existing modules

### `setupProject` function

This function does a variety of things to setup a SpaDES project, by assigned values to these arguments: 

- `paths` - a standardized set of paths, 
- `modules` -- either downloads them from a cloud repository or user identifies local ones
- `packages` to install and/or load (`require` argument) that are not already identified in the `modules`'s metadata
- `params` - to set parameter values for any of the `modules`
- `options` - to set base `R` `options`

See `?setupProject()` for more details.

### Default values

One of the important reasons for using `setupProject` is that there are many default values that can be taken advantage of, keeping code cleaner and shorter in many cases.

### Setting up the `SpaDES.core::simInit` call

The output from `setupProject` is a list with several named elements. These are intended to be passed directly to `simInit` to initiate a `simList` and potentially a `spades` call.

#### Arguments as values or urls

For most arguments, the values can either be named lists or character vectors of strings that end in `.R` that represent `urls` to cloud or local R scripts that will be sourced.  This allows a user to start with very simple argument values and progressively add arbitrary complexity as a project becomes larger. 

#### Arguments sourced sequentially

The argument values in each of the arguments are sourced sequentially, so a previous value can be used by a subsequent value. 

SpaDES` and other packages

```{r install-spades-project}
if (!require("SpaDES.project")) {
  {install.packages("SpaDES.project", repos = "predictiveecology.r-universe.dev")
   require("SpaDES.project")}
}
```


#### Arguments not sourced to .GlobalEnv

```{r clean1,echo=FALSE}
## cleanup / restore state
origLibPaths <- .libPaths()[1]
options(Require.verbose = 2) # so install.packages isn't super verbose
knitr::opts_knit$set(root.dir = tempdir()) 
```


#### Set paths for a SpaDES project

```{r simplest}
library(SpaDES.project)
setupProject()
```

#### set relative paths & modules, install packages in isolated folder

```{r clean0,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_2"), create = TRUE ))
```

```{r example2,eval=FALSE}
out <- setupProject(
  paths = list(modulePath = "m", 
               projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean2,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_3"), create = TRUE ))
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
```

#### With options and params set


```{r example3,eval=FALSE}
out <- setupProject(
  options = list(reproducible.useTerra = TRUE),
  params = list(Biomass_borealDataPrep = list(.plots = "screen")),
  paths = list(modulePath = "m",
               projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean3,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_4"), create = TRUE ))
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
```

## using an options file that is remote

```{r example_4,eval=FALSE} 
out <- setupProject(
  options = c(
    "PredictiveEcology/SpaDES.project@transition/inst/options.R"
  ),
  params = list(
    Biomass_borealDataPrep = list(.plots = "screen")
  ),
  paths = list(modulePath = "m",
               projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean4,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_5"), create = TRUE ))
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
```

## setting arbitrary arguments, using defaultDots (1)

```{r example_5,eval=FALSE}
out <- setupProject(
  name = "example_5", # puts in a folder with this name
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  sideEffects = "PredictiveEcology/SpaDES.project@transition/inst/sideEffects.R",

  # if mode and studyAreaName are not available in the .GlobalEnv, then will use these
  defaultDots = list(mode = "development",
                     studyAreaName = "MB"),
  mode = mode, # may not exist in the .GlobalEnv, so `setup*` will use the defaultDots above
  studyAreaName = studyAreaName#, # same as previous argument.
  # params = list("Biomass_borealDataPrep" = list(.useCache = mode))
)
```

```{r clean5,echo=FALSE}
## cleanup / restore state
if (is.null(getOption("repos")) || !"CRAN" %in% names(getOption("repos"))) {
 options(repos = c(CRAN = "https://cloud.r-project.org"))
}
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_6"), create = TRUE ))
```

## setting arbitrary arguments, using defaultDots (2)

```{r example6,eval=FALSE}
out <- setupProject(
  name = "example_6", # must be same as projectPath if both specified
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  config = "LandWeb",
  defaultDots = list(.mode = "development",
                     studyAreaName = "MB"),
  mode = .mode, studyAreaName = studyAreaName#,
  # params = list("Biomass_borealDataPrep" = list(.useCache = mode))
)
```

```{r clean6,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_7"), create = TRUE ))
```

## Pass args from GlobalEnv

```{r example7,eval=FALSE}
studyAreaName <- "AB"
out <- setupProject(
  paths = list(projectPath = "example_7"),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  defaultDots = list(mode = "development",
                     studyAreaName = "MB"),
  mode = "development",
  studyAreaName = studyAreaName  # <----- pass it here, naming it
)
```

```{r clean7,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_8"), create = TRUE ))
```

## mixture of named list element, github file and local file for e.g., options
```{r example8,eval=FALSE}
out <- setupProject(
  options = list(
    reproducible.useTerra = TRUE,
    "PredictiveEcology/SpaDES.project@transition/inst/options.R",
    system.file("authentication.R", package = "SpaDES.project") # local file
  ),
  params = list(Biomass_borealDataPrep = list(.plots = "screen")),
  paths = list(modulePath = "m",
                 projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean8,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_9"), create = TRUE ))
```


## examples with studyArea argument

### passed in long-lat, for Alberta and British Columbia, Canada


```{r example9}
out <- setupProject(
  name = "example_9",
  studyArea = list("Al|Brit")
)
```


```{r clean9,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_10"), create = TRUE ))
```


### example 2 with studyArea, converted to BC Albers 3005, Alberta, BC, SK, with level 2 administrative boundaries

```{r explanationForExample10,eval=FALSE,echo=FALSE}
# example_10 doesn't run behind some firewalls, so fails too frequently; skip evaluation in vignette
```

```{r example10,eval=FALSE} 
out <- setupProject(
  name = "example_10",
  studyArea = list("Al|Brit|Sas", level = 2, epsg = "3005")
)
```

```{r clean10,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_11"), create = TRUE ))
```

## `require` and `objects` arguments

Using the `require` argument, calls `Require::Require()`, which *installs and loads* packages i.e., equivalent to `install.packages(...)` and `require(...)` on the named packages). `objects` accepts a list of arbitrary objects that will be returned at the end of this function call. Any code that needs executing will run, and they will have access to all the `packages` and `require` packages, plus any other arguments (e.g., `paths` or other named arguments in the `...`) that preceeded it in the call.


```{r example11,eval=FALSE}
out <- setupProject(
  paths = list(projectPath = "example_11"), # will deduce name of project from projectPath
  standAlone = TRUE,
  require = c(
    "PredictiveEcology/reproducible@development (>= 1.2.16.9017)",
    "PredictiveEcology/SpaDES.core@development (>= 1.1.0.9001)"
  ),
  modules = c(
    "PredictiveEcology/Biomass_speciesData@master",
    "PredictiveEcology/Biomass_borealDataPrep@development",
    "PredictiveEcology/Biomass_core@master",
    "PredictiveEcology/Biomass_validationKNN@master",
    "PredictiveEcology/Biomass_speciesParameters@development"
  ),
  objects = list(
    studyAreaLarge = terra::vect(
      terra::ext(-598722.985900015, -557858.350337621,
                 776827.300151124, 837385.414396185),
      crs = terra::crs("epsg:3978")
    ),
    studyArea = terra::vect(
      terra::ext(-598722.985900015, -578177.124187722,
                 779252.422377214, 809573.532597151),
      crs = terra::crs("epsg:3978")
    )
  )
)
```



```{r clean11,echo=FALSE,eval=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_12"), create = TRUE ))
```


## Passing named arguments as part of the `...`

Sometimes it is just as easy to pass objects directly to named arguments, skipping the use of the `objects` argument. These will be returned at the top level of the list, instead of within the `objects` list element. Recent versions of `SpaDES.core` allow `...` to be passed to `simInit`, so it can handle either using `objects` (the original way to pass arguments to `simInit`) or just arbitrarily named arguments.

```{r example12,eval=FALSE}
out <- setupProject(
  paths = list(projectPath = "example_12"), # will deduce name of project from projectPath
  standAlone = TRUE,
  require = c(
    "PredictiveEcology/reproducible@development (>= 1.2.16.9017)",
    "PredictiveEcology/SpaDES.core@development (>= 1.1.0.9001)"
  ),
  modules = c(
    "PredictiveEcology/Biomass_speciesData@master",
    "PredictiveEcology/Biomass_borealDataPrep@development",
    "PredictiveEcology/Biomass_core@master",
    "PredictiveEcology/Biomass_validationKNN@master",
    "PredictiveEcology/Biomass_speciesParameters@development"
  ),
  studyAreaLarge = terra::vect(
    terra::ext(-598722.985900015, -557858.350337621, 776827.300151124, 837385.414396185),
    crs = terra::crs("epsg:3978")
  ),
  studyArea = terra::vect(
    terra::ext(-598722.985900015, -578177.124187722, 779252.422377214, 809573.532597151),
    crs = terra::crs("epsg:3978")
  )
)
```


```{r clean12,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_13"), create = TRUE ))
```


## Make project-level change to .libPaths() that is persistent

```{r example13,eval=FALSE}
out <- setupProject(
  name = "example_13",
  package = "terra",
  updateRprofile = TRUE
)
```


