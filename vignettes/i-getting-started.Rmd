---
title: "SpaDES project setup"
author: "Eliot McIntire"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SpaDES project setup}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE
)

# Most are eval=FALSE within each chunk; but a few are not. Those must be eval=FALSE on GA and CRAN
SuggestedPkgsNeeded <- c("SpaDES.core", "igraph", "visNetwork", "ellipsis", "terra")
hasSuggests <- all(sapply(SuggestedPkgsNeeded, require, character.only = TRUE, quietly = TRUE))
useSuggests <- !(tolower(Sys.getenv("_R_CHECK_DEPENDS_ONLY_")) == "true")

knitr::opts_chunk$set(eval = hasSuggests && useSuggests && 
                       Sys.info()["user"] == "emcintir")# && interactive())
options(Ncpus = 1)

# options(Require.clonePkgs = TRUE)

```

```{r setCRAN,echo=FALSE}
## cleanup / restore state
if (is.null(getOption("repos")) || !"CRAN" %in% names(getOption("repos"))) {
 options(repos = c(CRAN = "https://cloud.r-project.org"))
}
```

# Getting started

`SpaDES` is a collection of R packages designed to provide a flexible framework for ecological analysis, simulations, forecasting, and other ecological tasks. At its core, a `SpaDES` analysis revolves around the concept of a "module" - a self-contained unit of code that performs a specific function and includes both machine-readable and human-readable metadata. In a typical `SpaDES` project, users often employ multiple modules, whether they've authored them or they've been contributed by others. This scalability introduces several challenges, including managing file paths (e.g., for data inputs, outputs, figures, modules, and packages), handling package dependencies, and coordinating the development of multiple modules simultaneously. While it is possible to develop a `SpaDES` project using methods familiar to the user, the `SpaDES.project` package streamlines this process, facilitating a clean, reproducible and reusable project setup for any project. Default settings ensure that project files and packages are kept isolated, preventing potential conflicts with other projects on the same computer.  

In the following section, we present a range of examples showcasing the utilization of the `setupProject()` function. To ensure a smooth understanding of these examples, we will begin by discussing the necessary prerequisites.  

## Setting Up Prerequisites: Installing System Dependencies, R, and RStudio  

To get started, users should have already installed R, RStudio, and possibly other system-level dependencies.  
[See vignette here](iv-Installing-R.html)  

Now that we've established the prerequisites, let's explore various examples of how to use the `setupProject()` function, ranging from simple to moderately complex scenarios.  

## Installing `SpaDES.project`

```{r install-spades-project}
if (!require("SpaDES.project")) {
  {install.packages("SpaDES.project", repos = "predictiveecology.r-universe.dev")
   require("SpaDES.project")}
}
```

## Start Working With Existing Modules

### `setupProject()` function

This function performs a variety of tasks to set up a SpaDES project by assigning values to these arguments:   

- `paths` - A standardized set of paths.  
- `modules` - Either downloads them from a cloud repository or user identifies local ones.  
- `packages` - To install and/or load (using the `require` argument) packages not already identified in the metadata of the `modules`.
- `params` - For setting parameter values for any of the `modules`.
- `options` - To configure basic `R` `options`.  

See `?setupProject()` for more details.

### Default values

One compelling reason to use `setupProject()` is the availability of numerous default values that can be leveraged, leading to cleaner and more concise code in many instances.  

### Setting up the `SpaDES.core::simInit` Call

The output from `setupProject()` is a list containing several named elements. These elements are designed to be passed directly to `simInit` to initialize a `simList` and, potentially, a `spades` call.  

#### **Arguments as values or urls**

For most arguments, the values can be either named lists or character vectors consisting of strings ending in `.R`, representing `urls` to cloud or local R scripts to be sourced. This flexibility enables users to begin with simple argument values and gradually introduce greater complexity as a project expands in scale.

#### **Arguments sourced sequentially**

The argument values within each of the arguments are sourced sequentially. This means that a previous value can be utilized by a subsequent one.   

```{r sequential,message=FALSE}
# Use the newValue in `secondValue`
out <- setupProject(name = "test",
             newValue = 1,
             secondValue = newValue + 1)
out[c("newValue", "secondValue")]

```



#### **Arguments not sourced to .GlobalEnv**

```{r clean1,echo=FALSE}
## cleanup / restore state
origLibPaths <- .libPaths()[1]
options(Require.verbose = 2) # so install.packages isn't super verbose
knitr::opts_knit$set(root.dir = tempdir()) 
```

The `.GlobalEnv` in `R` is special because it is in the search path of any user-created function. This is very convenient, but also provides the potential for many problems. For example, a variable could be misspelled in a code chunck, but the code doesn't fail because the `.GlobalEnv` has the same variable, spelled correctly.

```{r Global,eval=FALSE}
# Gets the wrong version of the module
githubRepo = "PredictiveEcology/Biomass_core@development" # incorrect one -- used in error
out <- setupProject(
             gitHubRepo = "PredictiveEcology/Biomass_core@main", # The correct one --> not used
             modules = githubRepo,
             packages = NULL # no packages for this demonstration
)


```


#### **Set paths for a SpaDES project**

```{r simplest}
library(SpaDES.project)
setupProject()
```

#### **set relative paths & modules, install packages in isolated folder**

```{r clean0,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_2"), create = TRUE ))
```

```{r example2,eval=FALSE}
out <- setupProject(
  paths = list(modulePath = "m", 
               projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean2,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_3"), create = TRUE ))
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
```

#### **With options and params set**


```{r example3,eval=FALSE}
out <- setupProject(
  options = list(reproducible.useTerra = TRUE),
  params = list(Biomass_borealDataPrep = list(.plots = "screen")),
  paths = list(modulePath = "m",
               projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean3,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_4"), create = TRUE ))
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
```

## using an options file that is remote

```{r example_4,eval=FALSE} 
out <- setupProject(
  options = c(
    "PredictiveEcology/SpaDES.project@transition/inst/options.R"
  ),
  params = list(
    Biomass_borealDataPrep = list(.plots = "screen")
  ),
  paths = list(modulePath = "m",
               projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean4,echo=FALSE}
## cleanup / restore state
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_5"), create = TRUE ))
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
```

## setting arbitrary arguments, using defaultDots (1)

```{r example_5,eval=FALSE}
out <- setupProject(
  name = "example_5", # puts in a folder with this name
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  sideEffects = "PredictiveEcology/SpaDES.project@transition/inst/sideEffects.R",

  # if mode and studyAreaName are not available in the .GlobalEnv, then will use these
  defaultDots = list(mode = "development",
                     studyAreaName = "MB"),
  mode = mode, # may not exist in the .GlobalEnv, so `setup*` will use the defaultDots above
  studyAreaName = studyAreaName#, # same as previous argument.
  # params = list("Biomass_borealDataPrep" = list(.useCache = mode))
)
```

```{r clean5,echo=FALSE}
## cleanup / restore state
if (is.null(getOption("repos")) || !"CRAN" %in% names(getOption("repos"))) {
 options(repos = c(CRAN = "https://cloud.r-project.org"))
}
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_6"), create = TRUE ))
```

## setting arbitrary arguments, using defaultDots (2)

```{r example6,eval=FALSE}
out <- setupProject(
  name = "example_6", # must be same as projectPath if both specified
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  config = "LandWeb",
  defaultDots = list(.mode = "development",
                     studyAreaName = "MB"),
  mode = .mode, studyAreaName = studyAreaName#,
  # params = list("Biomass_borealDataPrep" = list(.useCache = mode))
)
```

```{r clean6,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_7"), create = TRUE ))
```

## Pass args from GlobalEnv

```{r example7,eval=FALSE}
studyAreaName <- "AB"
out <- setupProject(
  paths = list(projectPath = "example_7"),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  defaultDots = list(mode = "development",
                     studyAreaName = "MB"),
  mode = "development",
  studyAreaName = studyAreaName  # <----- pass it here, naming it
)
```

```{r clean7,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_8"), create = TRUE ))
```

## mixture of named list element, github file and local file for e.g., options
```{r example8,eval=FALSE}
out <- setupProject(
  options = list(
    reproducible.useTerra = TRUE,
    "PredictiveEcology/SpaDES.project@transition/inst/options.R",
    system.file("authentication.R", package = "SpaDES.project") # local file
  ),
  params = list(Biomass_borealDataPrep = list(.plots = "screen")),
  paths = list(modulePath = "m",
                 projectPath = "."), # within vignette, project dir cannot be changed; user likely will
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
```

```{r clean8,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_9"), create = TRUE ))
```


### `studyArea` argument

`?setupStudyArea` for more details. A user can choose to use the internal `setupStudyArea` function, which will use the `gadm` global database. Setting the `studyArea` argument to a `list` will trigger the use of `setupStudyArea`.

#### **Alberta and British Columbia, Canada**

In this example, we will select an area in northwestern Alberta and the adjacent northeastern BC, Canada. We use the internal matching, because we aren't sure of the exact names: for the top level (`NAME_1`), we use either "Al" or "Brit", separated by the "or" symbol, `|`. For the second level, we do the same, but specify using the names in that column. If a user does not know which values exist, they can not specify `NAME_2`, then visualize the resulting map and click on values, such as:


```{r example9}
out <- setupStudyArea(list("Al|Brit", level = 2))

if (interactive()) {
  library(quickPlot)
  dev() # open a non-RStudio window; can't use RStudio for `clickValues` below
  Plot(out)
  val <- clickValues()
  out <- setupStudyArea(list("Al|Brit", level = 2, NAME_2 = val$NAME_2))
  Plot(out, new = TRUE) # need "new = TRUE" to clear previous map 
}

# Can pick multiple parts with partial matching
out <- setupStudyArea(list("Al|Brit", level = 2, NAME_2 = "19|18|17|Peace"))

```


```{r clean9,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_10"), create = TRUE ))
```


#### **Specify an `epsg`**

We can get the `studyArea` in a different projection if we specify the `epsg` code.

```{r explanationForExample10,eval=FALSE,echo=FALSE}
# example_10 doesn't run behind some firewalls, so fails too frequently; skip evaluation in vignette
```

```{r example10,eval=FALSE} 
out <- setupProject(
  name = "example_10",
  studyArea = list("Al|Brit|Sas", level = 2, epsg = "3005")
)
```

```{r clean10,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_11"), create = TRUE ))
```

## `require` and `objects` arguments

Using the `require` argument, calls `Require::Require()`, which *installs and loads* packages i.e., equivalent to `install.packages(...)` and `require(...)` on the named packages). `objects` accepts a list of arbitrary objects that will be returned at the end of this function call. Any code that needs executing will run, and they will have access to all the `packages` and `require` packages, plus any other arguments (e.g., `paths` or other named arguments in the `...`) that preceded it in the call.


```{r example11,eval=FALSE}
out <- setupProject(
  paths = list(projectPath = "example_11"), # will deduce name of project from projectPath
  standAlone = TRUE,
  require = c(
    "PredictiveEcology/reproducible@development (>= 1.2.16.9017)",
    "PredictiveEcology/SpaDES.core@development (>= 1.1.0.9001)"
  ),
  modules = c(
    "PredictiveEcology/Biomass_speciesData@master",
    "PredictiveEcology/Biomass_borealDataPrep@development",
    "PredictiveEcology/Biomass_core@master",
    "PredictiveEcology/Biomass_validationKNN@master",
    "PredictiveEcology/Biomass_speciesParameters@development"
  ),
  objects = list(
    studyAreaLarge = terra::vect(
      terra::ext(-598722, -557858,
                 776827, 837385),
      crs = terra::crs("epsg:3978")
    ),
    studyArea = terra::vect(
      terra::ext(-598722, -578177,
                 779252, 809573),
      crs = terra::crs("epsg:3978")
    )
  )
)
```



```{r clean11,echo=FALSE,eval=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_12"), create = TRUE ))
```


## Passing named arguments as part of the `...`

Sometimes it is just as easy to pass objects directly to named arguments, skipping the use of the `objects` argument. These will be returned at the top level of the list, instead of within the `objects` list element. Recent versions of `SpaDES.core` allow `...` to be passed to `simInit`, so it can handle either using `objects` (the original way to pass arguments to `simInit`) or just arbitrarily named arguments.

```{r example12,eval=FALSE}
out <- setupProject(
  paths = list(projectPath = "example_12"), # will deduce name of project from projectPath
  standAlone = TRUE,
  require = c(
    "PredictiveEcology/reproducible@development (>= 1.2.16.9017)",
    "PredictiveEcology/SpaDES.core@development (>= 1.1.0.9001)"
  ),
  modules = c(
    "PredictiveEcology/Biomass_speciesData@master",
    "PredictiveEcology/Biomass_borealDataPrep@development",
    "PredictiveEcology/Biomass_core@master",
    "PredictiveEcology/Biomass_validationKNN@master",
    "PredictiveEcology/Biomass_speciesParameters@development"
  ),
  studyAreaLarge = terra::vect(
    terra::ext(-598722, -557858, 776827, 837385),
    crs = terra::crs("epsg:3978")
  ),
  studyArea = terra::vect(
    terra::ext(-598722, -578177, 779252, 809573),
    crs = terra::crs("epsg:3978")
  )
)
```


```{r clean12,echo=FALSE}
## cleanup / restore state
# SpaDES.project::.teardownProject(out$paths, origLibPaths)
knitr::opts_knit$set(root.dir = Require::checkPath(file.path(tempdir(), "example_13"), create = TRUE ))
```


## Make project-level change to .libPaths() that is persistent

```{r example13,eval=FALSE}
out <- setupProject(
  name = "example_13",
  package = "terra",
  updateRprofile = TRUE
)
```


