% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setupProject.R
\name{setupProject}
\alias{setupProject}
\title{Sets up a new or existing SpaDES project}
\usage{
setupProject(
  name,
  paths,
  modules,
  packages,
  times,
  options,
  params,
  sideEffects,
  config,
  require = NULL,
  studyArea = NULL,
  Restart = getOption("SpaDES.project.Restart", FALSE),
  useGit = FALSE,
  setLinuxBinaryRepo = TRUE,
  standAlone = TRUE,
  libPaths = NULL,
  updateRprofile = getOption("Require.updateRprofile", FALSE),
  overwrite = FALSE,
  verbose = getOption("Require.verbose", 1L),
  defaultDots,
  dots,
  ...
)
}
\arguments{
\item{name}{Optional. If supplied, the name of the project. If not supplied, an
attempt will be made to extract the name from the \code{paths[["projectPath"]]}.
If this is a GitHub project, then it should indicate the full Github
repository and branch name, e.g., \code{"PredictiveEcology/WBI_forecasts@ChubatyPubNum12"}}

\item{paths}{a list with named elements, specifically, \code{modulePath}, \code{projectPath},
\code{packagePath} and all others that are in \code{SpaDES.core::setPaths()}
(i.e., \code{inputPath}, \code{outputPath}, \code{scratchPath}, \code{cachePath}, \code{rasterTmpDir}).
Each of these has a sensible default, which will be overridden but any user
supplied values.
See \link{setup}.}

\item{modules}{a character string of modules to pass to \code{getModule}. These
should be one of: simple name (e.g., \code{fireSense}) which will be searched for locally
in the \code{paths[["modulePath"]]}; or a GitHub repo with branch (\code{GitHubAccount/Repo@branch} e.g.,
\code{"PredictiveEcology/Biomass_core@development"}); or a character vector that identifies
one or more (not optional file extension) \code{.R} file(s) (local or GitHub)
to parse that will produce a character vector assigned to
the name "modules". If the entire project is a git repository,
then it will not try to re-get these modules; instead it will rely on the user
managing their git status outside of this function.
See \link{setup}.}

\item{packages}{Optional. A vector of packages that must exist in the \code{libPaths}.
This will be passed to \code{Require::Install}, i.e., these will be installed, but
not attached to the search path. See also the \code{require} argument.
See \link{setup}.}

\item{times}{Optional. This will be returned if supplied; if supplied, the values
can be used in e.g., \code{params}, e.g., \code{params = list(mod = list(startTime = times$start))}.
See help for \code{SpaDES.core::simInit}.}

\item{options}{Optional. Either a named list to be passed to \code{options}
or a character vector indicating one or more file(s) to source,
in the order provided. These will be sourced into a temporary environment (not
the \code{.GlobalEnv}), so they will not create globally accessible objects. See details.
See \link{setup}.}

\item{params}{Optional. Similar to \code{options}, however, this named list will be
returned, i.e., there are no side effects.
See \link{setup}.}

\item{sideEffects}{Optional. This can be an expression or one or more filenames or
a code chunk surrounded by \code{{...}}.
This/these will be parsed and evaluated, but nothing returned. This is intended
to be used for functions, such as cloud authentication or configurations,
that are run for their side effects only.
See \link{setup}.}

\item{config}{Still experimental linkage to the \code{SpaDES.config} package. Currently
not working.}

\item{require}{Optional. A character vector of packages to install \emph{and} attach
(with \code{Require::Require}). These will be installed and attached at the start
of \code{setupProject} so that a user can use these during \code{setupProject}.
See \link{setup}}

\item{studyArea}{Optional. If a list, it will be passed to
\code{geodata::gadm}. To specify a country other than the default \code{"CAN"},
the list must have a named element, \code{"country"}. All other named elements
will be passed to \code{gadm}. 2 additional named elements can be passed for
convenience, \code{subregion = "..."}, which will be grepped with the column
\code{NAME_1}, and \code{epsg = "..."}, so a user can pass an \code{epsg.io} code to
reproject the \code{studyArea}. See examples.}

\item{Restart}{If the \code{projectPath} is not the current path, and the session is in
Rstudio, and interactive, it will restart with a new Rstudio session with a
new project, with a root path set to \code{projectPath}. Default is \code{FALSE}.}

\item{useGit}{A logical. If \code{TRUE}, it will use \verb{git clone} and \verb{git checkout}
to get and change branch for each module, according to its specification in
\code{modules}. Otherwise it will get modules with \code{getModules}.}

\item{setLinuxBinaryRepo}{Logical. Should the binary RStudio Package Manager be used
on Linux (ignored if Windows)}

\item{standAlone}{A logical. Passed to \code{Require::standAlone}. This keeps all
packages installed in a project-level library, if \code{TRUE}. Default is \code{TRUE}.}

\item{libPaths}{Deprecated. Use \code{paths = list(packagePath = ...)}.}

\item{updateRprofile}{Logical. Should the \code{paths$packagePath} be set in the \code{.Rprofile}
file for this project. Note: if \code{paths$packagePath} is within the \code{tempdir()},
then there will be a warning, indicating this won't persist. If the user is
using \code{Rstudio} and the \code{paths$projectPath} is not the root of the current
Rstudio project, then a warning will be given, indicating the .Rprofile may not
be read upon restart.}

\item{overwrite}{Logical. Passed to \code{getModule}, and \code{setupParams}, \code{setupOptions}}

\item{verbose}{Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if \code{1} or TRUE, more outputs; \code{2} even more. NOTE: in
\code{Require} function, when \code{verbose >= 2}, the return object will have an
attribute: \code{attr(.., "Require")} which has lots of information about the
processes of the installs.}

\item{defaultDots}{A named list of any arbitrary R objects.
These can be supplied to give default values to objects that
are otherwise passed in with the \code{...}, i.e., not specifically named for these
\verb{setup*} functions. If named objects are supplied as top-level arguments, then
the \code{defaultDots} will be overridden. This can be particularly useful if the
arguments passed to \code{...} do not always exist, but rely on external e.g., batch
processing to optionally fill them. See examples.}

\item{dots}{Any other named objects passed as a list a user might want for other elements.}

\item{...}{Any other named objects a user might want.}
}
\value{
\code{setupProject} will return a named list with elements \code{modules}, \code{paths}, \code{params}, and \code{times}.
It will also append all elements passed by the user in the \code{...}.
This list  can be passed directly to \code{SpaDES.core::simInit()} or
\code{SpaDES.core::simInitAndSpades()} using a \code{do.call()}. See example.
}
\description{
\code{setupProject} calls a sequence of functions in this order:
\code{setupPaths},
\code{setupModules}, \code{setupPackages}, \code{setupOptions}, \code{setupSideEffects}, \code{setupParams},
\code{setupGitIgnore}. Because of this
order, settings in \code{options} can change \code{paths}, \code{times} can be used in \code{params},
for example.
This sequence will create folder structures, install & load packages indicated in the
\code{require} argument, set options, download or confirms
existence of modules, install missing
packages from both the modules \code{reqdPkgs} fields and the user passed
\code{packages}, assign parameters, and if desired, change the .Rprofile file for this
this project so that every time this project is opened, it has a specific
\code{.libPaths()}. There are a number of convenience elements described in the
section below. See Details.
}
\section{Objective}{


The overarching objectives for these functions are:

\enumerate{
\item To prepare what is needed for \code{simInit}.
\item To help a user eliminate virtually all assignments to the \code{.GlobalEnv},
as these create and encourage spaghetti code that becomes unreproducible
as the project increases in complexity.
\item Be very simple for beginners, but powerful enough to expand to almost
any needs of arbitrarily complex projects, using the same structure
\item Deal with the complexities of R package installation and loading when
working with modules that may have been created by many users
\item Allow every SpaDES project to have very similar structure, allowing
easy transition from one project to another, regardless of complexity.
}
}

\section{Convenience elements}{


\subsection{Sequential evaluation}{
Throughout these functions, efforts have been made to implement sequential evaluation,
within files and within lists. This means that a user can \emph{use} the values from an
upstream element in the list. For example, the following is valid:

\if{html}{\out{<div class="sourceCode">}}\preformatted{paths = list(projectPath = "here", modulePath = file.path(paths[["projectPath"]], "modules")
}\if{html}{\out{</div>}}

Because of such sequential evaluation, \code{paths}, \code{options}, and \code{params} files
can be sequential lists that have impose a hierarchy specified
by the order. For example, a user can first create a list of \emph{default} options,
then several lists of user-desired options behind an \verb{if (user("emcintir"))}
block that add new or override existing elements, followed by \code{machine} specific
values, such as paths.
}

\subsection{Values and/or files}{
The arguments, \code{paths}, \code{options}, and \code{params}, can all
understand lists of named values, character vectors, or a mixture by using a list where
named elements are values and unnamed elements are character strings/vectors. Any unnamed
character string/vector will be treated as a file path. If that file path has an \code{@} symbol,
it will be assumed to be a file that exists on \verb{https://github.com}. So a user can
pass values, or pointers to remote and/or local paths that themselves have values.

The following will set an option as declared, plus read the local file (with relative
path), plus download and read the cloud-hosted file.

\if{html}{\out{<div class="sourceCode">}}\preformatted{setupProject(
   options = list(reproducible.useTerra = TRUE,
                  "inst/options.R",
                  "PredictiveEcology/SpaDES.project@transition/inst/options.R")
                 )
   )
}\if{html}{\out{</div>}}

This approach allows for an organic growth of complexity, e.g., a user begins with
only named lists of values, but then as the number of values increases, it may be
helpful for clarity to put some in an external file.
}

\subsection{Specifying \code{paths}, \code{options}, \code{params}}{
If \code{paths}, \code{options}, and/or \code{params}are a character string
or character vector (or part of an unnamed list element) the string(s)
will be interpretted as files to parse. These files should contain R code that
specifies \emph{named lists}, where the names are one or more \code{paths}, \code{options},
or are module names, each with a named list of parameters for that named module.
This last named list for \code{params} follows the convention used for the \code{params} argument in
\code{simInit(..., params = )}. The \code{options} file should
not set \code{options} explicitly; only named lists. This enables options checking/validating
to occur within \code{setupOptions} and \code{setupParams}.

These files can use \code{paths}, \code{times}, plus any previous list in the sequence of
\code{params} or \code{options} specified.

A simplest case would be a file with this:
\code{opts <- list(reproducible.destinationPath = "~/destPath")}. All named lists will
be parsed into their own environment, and then will be sequentially evaluated (i.e.,
subsequent lists will have access to previous lists), with each named elements
setting or replacing the previously named element of the same name, creating a
single list. This final list will be assigned to \code{options()} inside \code{setupOptions}.
Because these are each parsed separately, it is not necessary to assign any list to
an object; and the objects, if named, can be any name, even the same name repeatedly.
The sequential nature means that a user can
have a named list of default settings first in the file, then those defaults can
be overridden by e.g., user-specific or machine-specific values that are
specified subsequently in the same file or in a separate file. Any functions
that are used must be available, e.g., prefixed \code{Require::normPath}.

NOTE: these will only parse items that are atomics (i.e., character, numeric, etc.),
named lists or either of these that are protected by 1 level of "if". This
will not work, therefore, for other side-effect elements, like authenticating
with a cloud service.

Several helper functions exist within \code{SpaDES.project} that may be useful, such
as \code{user(...)}, \code{machine(...)}
}

\subsection{Can hard code arguments that may be missing}{
To allow for batch submission, a user can specify code \code{argument = value} even if \code{value}
is missing. This type of specification will not work in normal parsing of arguments,
but it is designed to work here. In the next example, \code{.mode = .mode} can be specified,
but if R cannot find \code{.mode} for the right hand side, it will just skip with no error.
Thus a user can source a script with the following line from batch script where \code{.mode}
is specified. When running this line without that batch script specification, then this
will assign no value to \code{.mode}. We include \code{.nodes} which shows an example of
passing a value that does exist. The non-existent \code{.mode} will be returned in the \code{out},
but as an unevaluated, captured list element.

\if{html}{\out{<div class="sourceCode">}}\preformatted{.nodes <- 2
out <- setupProject(.mode = .mode,
                    .nodes = .nodes,
                    options = "inst/options.R"
                    )
}\if{html}{\out{</div>}}

}
}

\examples{
\dontrun{
## THESE EXAMPLES ARE NOT INTENDED TO BE RUN SEQUENTIALLY AS THEY WILL LOAD PACKAGES
## THAT WILL CONFLICT. PLEASE RESTART R BETWEEN EXAMPLES

library(SpaDES.project)
if (is.null(getOption("repos"))) {
  options(repos = c(CRAN = "https://cloud.r-project.org"))
}
oldDir <- setwd(Require::tempdir2())
origLibPaths <- .libPaths()

 ## simplest case; just creates folders
 out <- setupProject(
  name = "example_SpaDES_project"
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

# set relative paths & modules, install packages in isolated folder
out <- setupProject(
  name = "example_SpaDES_project",
  paths = list(projectPath = "SpaDES.project",
               modulePath = "m",
               scratchPath = tempdir()),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)
out

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## With options and params set
out <- setupProject(
  name = "example_SpaDES_project",
  options = list(reproducible.useTerra = TRUE),
  params = list(Biomass_borealDataPrep = list(.plots = "screen")),
  paths = list(modulePath = "m",
               projectPath = "SpaDES.project",
               scratchPath = tempdir()),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## using an options file that is remote
out <- setupProject(
  name = "example_SpaDES_project",
  options = c("PredictiveEcology/SpaDES.project@transition/inst/options.R"),
  params = list(Biomass_borealDataPrep = list(.plots = "screen")),
  paths = list(modulePath = "m", projectPath = "~/GitHub/SpaDES.project",
                          scratchPath = tempdir()),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## setting arbitrary arguments, using defaultDots (1)
out <- setupProject(
  name = "example_SpaDES_project",
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  sideEffects = "PredictiveEcology/SpaDES.project@transition/inst/sideEffects.R",

  # if mode and studyAreaName are not available in the .GlobalEnv, then will use these
  defaultDots = list(mode = "development",
                     studyAreaName = "MB"),
  mode = mode, # may not exist in the .GlobalEnv, so `setup*` will use the defaultDots above
  studyAreaName = studyAreaName#, # same as previous argument.
  # params = list("Biomass_borealDataPrep" = list(.useCache = mode))
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## setting arbitrary arguments, using defaultDots (2)
out <- setupProject(
  name = "example_SpaDES_project",
  paths = list(projectPath = "LandWeb"),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  config = "LandWeb",
  defaultDots = list(mode = "development",
                     studyAreaName = "MB"),
  mode = mode, studyAreaName = studyAreaName#,
  # params = list("Biomass_borealDataPrep" = list(.useCache = mode))
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## Pass args from GlobalEnv
studyAreaName <- "AB"
out <- setupProject(
  name = "example_SpaDES_project",
  paths = list(projectPath = "LandWeb"),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development",
  defaultDots = list(mode = "development",
                     studyAreaName = "MB"),
  mode = "development",
  studyAreaName = studyAreaName
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## mixture of named list element, github file and local file for e.g., options
out <- setupProject(
  name = "example_SpaDES_project",
  options = list(
    reproducible.useTerra = TRUE,
    "PredictiveEcology/SpaDES.project@transition/inst/options.R",
    system.file("authentication.R", package = "SpaDES.project") # local file
  ),
  params = list(Biomass_borealDataPrep = list(.plots = "screen")),
  paths = list(modulePath = "m",
               projectPath = "SpaDES.project",
               scratchPath = tempdir()),
  modules = "PredictiveEcology/Biomass_borealDataPrep@development"
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## example with studyArea, left in long-lat, for Alberta and British Columbia, Canada
out <- setupProject(
  name = "example_SpaDES_project",
  studyArea = list("Al|Brit")
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

# example 2 with studyArea, converted to BC Albers 3005, Alberta, BC, SK,
#    with level 2 administrative boundaries
out <- setupProject(
  name = "example_SpaDES_project",
  studyArea = list("Al|Brit|Sas", level = 2, epsg = "3005")
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## If using SpaDES.core, the return object can be passed to `simInit` via `do.call`:
# do.call(simInit, out)

## load packages using `require` argument
out <- setupProject(
  paths = list(projectPath = "MEE_Paper"), # will deduce name of project from projectPath
  standAlone = TRUE,
  require = c("PredictiveEcology/reproducible@development (>= 1.2.16.9017)",
              "PredictiveEcology/SpaDES.core@development (>= 1.1.0.9001)"),
  modules = c("PredictiveEcology/Biomass_speciesData@master",
              "PredictiveEcology/Biomass_borealDataPrep@development",
              "PredictiveEcology/Biomass_core@master",
              "PredictiveEcology/Biomass_validationKNN@master",
              "PredictiveEcology/Biomass_speciesParameters@development")
  )
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

## Make project-level change to .libPaths() that is persistent
setwd(tempdir())
out <- setupProject(
  name = "example_SpaDES_project",
  package = "terra",
  updateRprofile = TRUE
)

## cleanup / restore state
.teardownProject(out$paths, origLibPaths)

setwd(oldDir)
}
}
\seealso{
\code{\link[=setupPaths]{setupPaths()}}, \code{\link[=setupOptions]{setupOptions()}}, \code{\link[=setupPackages]{setupPackages()}},
\code{\link[=setupModules]{setupModules()}}, \code{\link[=setupGitIgnore]{setupGitIgnore()}}. Also, helpful functions such as
\code{\link[=user]{user()}}, \code{\link[=machine]{machine()}}, \code{\link[=node]{node()}}
}
