% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setupProject.R
\name{setupProject}
\alias{setupProject}
\title{Sets up a new or existing SpaDES project}
\usage{
setupProject(
  name,
  paths,
  modules,
  packages,
  times,
  options,
  params,
  sideEffects,
  config,
  require = NULL,
  studyArea = NULL,
  Restart = getOption("SpaDES.project.Restart", FALSE),
  useGit = FALSE,
  setLinuxBinaryRepo = TRUE,
  standAlone = TRUE,
  libPaths = NULL,
  updateRprofile = getOption("Require.updateRprofile", FALSE),
  overwrite = FALSE,
  verbose = getOption("Require.verbose", 1L),
  defaultDots,
  dots,
  ...
)
}
\arguments{
\item{name}{Optional. If supplied, the name of the project. If not supplied, an
attempt will be made to extract the name from the \code{paths[["projectPath"]]}.
If this is a GitHub project, then it should indicate the full Github
repository and branch name, e.g., \code{"PredictiveEcology/WBI_forecasts@ChubatyPubNum12"}}

\item{paths}{a list with named elements, specifically, \code{modulePath}, \code{projectPath},
\code{packagePath} and all others that are in \code{SpaDES.core::setPaths()}
(i.e., \code{inputPath}, \code{outputPath}, \code{scratchPath}, \code{cachePath}, \code{rasterTmpDir}).
Each of these has a sensible default, which will be overridden but any user
supplied values.
See \link{setup}.}

\item{modules}{a character string of modules to pass to \code{getModule}. These
should be one of: simple name (e.g., \code{fireSense}) which will be searched for locally
in the \code{paths[["modulePath"]]}; or a GitHub repo with branch (\code{GitHubAccount/Repo@branch} e.g.,
\code{"PredictiveEcology/Biomass_core@development"}); or a character vector that identifies
one or more (not optional file extension) \code{.R} file(s) (local or GitHub)
to parse that will produce a character vector assigned to
the name "modules". If the entire project is a git repository,
then it will not try to re-get these modules; instead it will rely on the user
managing their git status outside of this function.
See \link{setup}.}

\item{packages}{Optional. A vector of packages that must exist in the \code{libPaths}.
This will be passed to \code{Require::Install}, i.e., these will be installed, but
not attached to the search path. See also the \code{require} argument.
See \link{setup}.}

\item{times}{Optional. This will be returned if supplied; if supplied, the values
can be used in e.g., \code{params}, e.g., \code{params = list(mod = list(startTime = times$start))}.
See help for \code{SpaDES.core::simInit}.}

\item{options}{Optional. Either a named list to be passed to \code{options}
or a character vector indicating one or more file(s) to source,
in the order provided. These will be sourced into a temporary environment (not
the \code{.GlobalEnv}), so they will not create globally accessible objects. See details.
See \link{setup}.}

\item{params}{Optional. Similar to \code{options}, however, this named list will be
returned, i.e., there are no side effects.
See \link{setup}.}

\item{sideEffects}{Optional. This can be an expression or one or more filenames or
a code chunk surrounded by \code{{...}}.
If a non-text files is specified (e.g., \emph{not .txt or .R} currently),
these files will simply be downloaded, using their relative path as specified
in the github notation. They will be downloaded or accessed locally at that
relative path.
If these file names represent scripts, this/these will be parsed and evaluated,
but nothing returned. This is intended
to be used for functions, such as cloud authentication or configurations,
that are run for their side effects only.}

\item{config}{Still experimental linkage to the \code{SpaDES.config} package. Currently
not working.}

\item{require}{Optional. A character vector of packages to install \emph{and} attach
(with \code{Require::Require}). These will be installed and attached at the start
of \code{setupProject} so that a user can use these during \code{setupProject}.
See \link{setup}}

\item{studyArea}{Optional. If a list, it will be passed to
\code{geodata::gadm}. To specify a country other than the default \code{"CAN"},
the list must have a named element, \code{"country"}. All other named elements
will be passed to \code{gadm}. 2 additional named elements can be passed for
convenience, \code{subregion = "..."}, which will be grepped with the column
\code{NAME_1}, and \code{epsg = "..."}, so a user can pass an \code{epsg.io} code to
reproject the \code{studyArea}. See examples.}

\item{Restart}{If the \code{projectPath} is not the current path, and the session is in
Rstudio, and interactive, it will restart with a new Rstudio session with a
new project, with a root path set to \code{projectPath}. Default is \code{FALSE}.}

\item{useGit}{A logical. If \code{TRUE}, it will use \verb{git clone} and \verb{git checkout}
to get and change branch for each module, according to its specification in
\code{modules}. Otherwise it will get modules with \code{getModules}. NOTE: \emph{CREATING} A
GIT REPOSITORY AND SETTING MODULES AS GIT SUBMODULES IS NOT YET IMPLEMENTED.
IT IS FINE IF THE PROJECT IS ALREADY A GIT REPOSITORY.}

\item{setLinuxBinaryRepo}{Logical. Should the binary RStudio Package Manager be used
on Linux (ignored if Windows)}

\item{standAlone}{A logical. Passed to \code{Require::standAlone}. This keeps all
packages installed in a project-level library, if \code{TRUE}. Default is \code{TRUE}.}

\item{libPaths}{Deprecated. Use \code{paths = list(packagePath = ...)}.}

\item{updateRprofile}{Logical. Should the \code{paths$packagePath} be set in the \code{.Rprofile}
file for this project. Note: if \code{paths$packagePath} is within the \code{tempdir()},
then there will be a warning, indicating this won't persist. If the user is
using \code{Rstudio} and the \code{paths$projectPath} is not the root of the current
Rstudio project, then a warning will be given, indicating the .Rprofile may not
be read upon restart.}

\item{overwrite}{Logical. Passed to \code{getModule}, and \code{setupParams}, \code{setupOptions}}

\item{verbose}{Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if \code{1} or TRUE, more outputs; \code{2} even more. NOTE: in
\code{Require} function, when \code{verbose >= 2}, the return object will have an
attribute: \code{attr(.., "Require")} which has lots of information about the
processes of the installs.}

\item{defaultDots}{A named list of any arbitrary R objects.
These can be supplied to give default values to objects that
are otherwise passed in with the \code{...}, i.e., not specifically named for these
\verb{setup*} functions. If named objects are supplied as top-level arguments, then
the \code{defaultDots} will be overridden. This can be particularly useful if the
arguments passed to \code{...} do not always exist, but rely on external e.g., batch
processing to optionally fill them. See examples.}

\item{dots}{Any other named objects passed as a list a user might want for other elements.}

\item{...}{further named arguments that acts like \code{objects}, but a different
way to specify them. These can be anything. The general use case
is to create the \code{objects} that are would be passed to
\code{SpaDES.core::simInit}, or \code{SpaDES.core::simInitAndSpades},
(e.g. \code{studyAreaName} or \code{objects}) or additional objects to be passed to the simulation
(in older versions of \code{SpaDES.core}, these were passed as a named list
to the \code{objects} argument). \strong{Order matters}. These are sequentially evaluated,
and also any arguments that are specified before the named arguments
e.g., \code{name}, \code{paths}, will be evaluated prior to any of the named arguments,
i.e., "at the start" of the \code{setupProject}.
If placed after the first named argument, then they will be evaluated at the
end of the \code{setupProject}, so can access all the packages, objects, etc.}
}
\value{
\code{setupProject} will return a named list with elements \code{modules}, \code{paths}, \code{params}, and \code{times}.
The goal of this list is to contain list elements that can be passed directly
to \code{simInit}
NOTE: both \code{projectPath} and \code{packagePath} will be omitted in the \code{paths} list
as they are used to
set current directory (found with \code{getwd()}) and \code{.libPaths()[1]}, and \code{simInit}
does not accept these. \code{setupPaths} will return these two paths as it is not
expected to be passed directly to \code{simInit}.
It will also append all elements passed by the user in the \code{...}.
This list  can be passed directly to \code{SpaDES.core::simInit()} or
\code{SpaDES.core::simInitAndSpades()} using a \code{do.call()}. See example.
}
\description{
\code{setupProject} calls a sequence of functions in this order:
\code{setupPaths}, \code{setupModules}, \code{setupPackages}, \code{setupOptions},
\code{setupSideEffects}, \code{setupParams},
\code{setupGitIgnore}.

This sequence will create folder structures, install missing packages from those
listed in either the \code{packages}, \code{require} arguments or in the modules \code{reqdPkgs} fields,
load packages (only those in the \code{require} argument), set options, download or
confirm the existence of modules. It will also return elements that can be passed
directly to \code{simInit}  or \code{simInitAndSpades}, specifically, \code{modules}, \code{params},
\code{paths}, \code{times}, and any named elements passed to \code{...}. This function will also
, if desired, change the .Rprofile file for this project so that every time
the project is opened, it has a specific \code{.libPaths()}.

There are a number of convenience elements described in the section below. See Details.
Because of this sequence, users can take advantage of settings (i.e., objects)
that happen (are created) before others. For example, users can set \code{paths}
then use the \code{paths} list to set \code{options} that will can update/change \code{paths},
or set \code{times} and use the \code{times} list for certain entries in \code{params}.
}
\section{Objective}{


The overarching objectives for these functions are:

\enumerate{
\item To prepare what is needed for \code{simInit}.
\item To help a user eliminate virtually all assignments to the \code{.GlobalEnv},
as these create and encourage spaghetti code that becomes unreproducible
as the project increases in complexity.
\item Be very simple for beginners, but powerful enough to expand to almost
any needs of arbitrarily complex projects, using the same structure
\item Deal with the complexities of R package installation and loading when
working with modules that may have been created by many users
\item Create a common SpaDES project structure, allowing
easy transition from one project to another, regardless of complexity.
}
}

\section{Convenience elements}{


\subsection{Sequential evaluation}{
Throughout these functions, efforts have been made to implement sequential evaluation,
within files and within lists. This means that a user can \emph{use} the values from an
upstream element in the list. For example, the following where \code{projectPath} is
part of the list that will be assigned to the \code{paths} argument and it is then
used in the subsequent list element is valid:

\if{html}{\out{<div class="sourceCode">}}\preformatted{setupPaths(paths = list(projectPath = "here",
                        modulePath = file.path(paths[["projectPath"]], "modules")))
}\if{html}{\out{</div>}}

Because of such sequential evaluation, \code{paths}, \code{options}, and \code{params} files
can be sequential lists that have impose a hierarchy specified
by the order. For example, a user can first create a list of \emph{default} options,
then several lists of user-desired options behind an \verb{if (user("emcintir"))}
block that add new or override existing elements, followed by \code{machine} specific
values, such as paths.
}

\subsection{Values and/or files}{
The arguments, \code{paths}, \code{options}, and \code{params}, can all
understand lists of named values, character vectors, or a mixture by using a list where
named elements are values and unnamed elements are character strings/vectors. Any unnamed
character string/vector will be treated as a file path. If that file path has an \code{@} symbol,
it will be assumed to be a file that exists on \verb{https://github.com}. So a user can
pass values, or pointers to remote and/or local paths that themselves have values.

The following will set an option as declared, plus read the local file (with relative
path), plus download and read the cloud-hosted file.

\if{html}{\out{<div class="sourceCode">}}\preformatted{setupProject(
   options = list(reproducible.useTerra = TRUE,
                  "inst/options.R",
                  "PredictiveEcology/SpaDES.project@transition/inst/options.R")
                 )
   )
}\if{html}{\out{</div>}}

This approach allows for an organic growth of complexity, e.g., a user begins with
only named lists of values, but then as the number of values increases, it may be
helpful for clarity to put some in an external file.
}

\subsection{Specifying \code{paths}, \code{options}, \code{params}}{
If \code{paths}, \code{options}, and/or \code{params}are a character string
or character vector (or part of an unnamed list element) the string(s)
will be interpretted as files to parse. These files should contain R code that
specifies \emph{named lists}, where the names are one or more \code{paths}, \code{options},
or are module names, each with a named list of parameters for that named module.
This last named list for \code{params} follows the convention used for the \code{params} argument in
\code{simInit(..., params = )}. The \code{options} file should
not set \code{options} explicitly; only named lists. This enables options checking/validating
to occur within \code{setupOptions} and \code{setupParams}.

These files can use \code{paths}, \code{times}, plus any previous list in the sequence of
\code{params} or \code{options} specified.

A simplest case would be a file with this:
\code{opts <- list(reproducible.destinationPath = "~/destPath")}. All named lists will
be parsed into their own environment, and then will be sequentially evaluated (i.e.,
subsequent lists will have access to previous lists), with each named elements
setting or replacing the previously named element of the same name, creating a
single list. This final list will be assigned to \code{options()} inside \code{setupOptions}.
Because these are each parsed separately, it is not necessary to assign any list to
an object; and the objects, if named, can be any name, even the same name repeatedly.
The sequential nature means that a user can
have a named list of default settings first in the file, then those defaults can
be overridden by e.g., user-specific or machine-specific values that are
specified subsequently in the same file or in a separate file. Any functions
that are used must be available, e.g., prefixed \code{Require::normPath}.

NOTE: these will only parse items that are atomics (i.e., character, numeric, etc.),
named lists or either of these that are protected by 1 level of "if". This
will not work, therefore, for other side-effect elements, like authenticating
with a cloud service.

Several helper functions exist within \code{SpaDES.project} that may be useful, such
as \code{user(...)}, \code{machine(...)}
}

\subsection{Can hard code arguments that may be missing}{
To allow for batch submission, a user can specify code \code{argument = value} even if \code{value}
is missing. This type of specification will not work in normal parsing of arguments,
but it is designed to work here. In the next example, \code{.mode = .mode} can be specified,
but if R cannot find \code{.mode} for the right hand side, it will just skip with no error.
Thus a user can source a script with the following line from batch script where \code{.mode}
is specified. When running this line without that batch script specification, then this
will assign no value to \code{.mode}. We include \code{.nodes} which shows an example of
passing a value that does exist. The non-existent \code{.mode} will be returned in the \code{out},
but as an unevaluated, captured list element.

\if{html}{\out{<div class="sourceCode">}}\preformatted{.nodes <- 2
out <- setupProject(.mode = .mode,
                    .nodes = .nodes,
                    options = "inst/options.R"
                    )
}\if{html}{\out{</div>}}

}
}

\examples{
## THESE EXAMPLES ARE NOT INTENDED TO BE RUN SEQUENTIALLY AS THEY WILL LOAD PACKAGES
## THAT WILL CONFLICT. PLEASE RESTART R BETWEEN EXAMPLES
library(SpaDES.project)

# Run all tests in a temporary directory, do not disrupt user's current project
\dontshow{tmpdir <- Require::tempdir2() # for testing tempdir2 is better}
\dontshow{
if (is.null(getOption("repos"))) {
  options(repos = c(CRAN = "https://cloud.r-project.org"))
}
}
 ## simplest case; just creates folders
out <- setupProject(
  paths = list(projectPath = ".") #
)
}
\seealso{
\code{\link[=setupPaths]{setupPaths()}}, \code{\link[=setupOptions]{setupOptions()}}, \code{\link[=setupPackages]{setupPackages()}},
\code{\link[=setupModules]{setupModules()}}, \code{\link[=setupGitIgnore]{setupGitIgnore()}}. Also, helpful functions such as
\code{\link[=user]{user()}}, \code{\link[=machine]{machine()}}, \code{\link[=node]{node()}}

\code{vignette("SpaDES project setup", package = "SpaDES.project")}
}
